/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
   file Copyright.txt or https://cmake.org/licensing for details.  */
#include "cmGlobalFastbuildGenerator.h"

#include "cmComputeLinkInformation.h"
#include "cmCustomCommandGenerator.h"
#include "cmDocumentationEntry.h"
#include "cmFastbuildLinkLineComputer.h"
#include "cmFastbuildTargetGenerator.h"
#include "cmGeneratorTarget.h"
#include "cmGlobalGenerator.h"
#include "cmGlobalGeneratorFactory.h"
#include "cmLocalGenerator.h"
#include "cmSourceFile.h"
#include "cmState.h"
#include "cmake.h"

cmGlobalFastbuildGenerator::cmGlobalFastbuildGenerator(cmake* cm)
  : cmGlobalCommonGenerator(cm)
{
#ifdef _WIN32
  cm->GetState()->SetWindowsShell(true);
#endif
  this->FindMakeProgramFile = "CMakeFastbuildFindMake.cmake";
}

cmGlobalGeneratorFactory* cmGlobalFastbuildGenerator::NewFactory()
{
  return new cmGlobalGeneratorSimpleFactory<cmGlobalFastbuildGenerator>();
}

void cmGlobalFastbuildGenerator::GetDocumentation(cmDocumentationEntry& entry)
{
  entry.Name = cmGlobalFastbuildGenerator::GetActualName();
  entry.Brief = "Generates Fastbuild .bff makefiles.";
}

void cmGlobalFastbuildGenerator::AppendDirectoryForConfig(
  const std::string& prefix, const std::string& config,
  const std::string& suffix, std::string& dir)
{
  // TODO
}

void cmGlobalFastbuildGenerator::ComputeTargetObjectDirectory(
  cmGeneratorTarget* gt) const
{
  // TODO
}

cmLinkLineComputer* cmGlobalFastbuildGenerator::CreateLinkLineComputer(
  cmOutputConverter* outputConverter, cmStateDirectory const& stateDir) const
{
  return new cmFastBuildLinkLineComputer(
    outputConverter,
    this->LocalGenerators[0]->GetStateSnapshot().GetDirectory(), this);
}

cmLocalGenerator* cmGlobalFastbuildGenerator::CreateLocalGenerator(
  cmMakefile* makefile)
{
  return new cmLocalFastbuildGenerator(this, makefile);
}

void cmGlobalFastbuildGenerator::EnableLanguage(
  std::vector<std::string> const& lang, cmMakefile* mf, bool optional)
{
  this->cmGlobalGenerator::EnableLanguage(lang, mf, optional);

  // Ensure configuration types is not none. Default to
  // Debug;Release;MinSizeRel;RelWithDebInfo
  if (!mf->GetDefinition("CMAKE_CONFIGURATION_TYPES")) {
    mf->AddCacheDefinition(
      "CMAKE_CONFIGURATION_TYPES", "Debug;Release;MinSizeRel;RelWithDebInfo",
      "Semicolon separated list of supported configuration types, "
      "only supports Debug, Release, MinSizeRel, and RelWithDebInfo, "
      "anything else will be ignored.",
      cmStateEnums::STRING);
  }
}

void cmGlobalFastbuildGenerator::Generate()
{
  // Run the normal generation process
  cmGlobalGenerator::Generate();

  // Creat the top-level fastbuild bff file
  GenerateBffFile();
}

std::vector<cmGlobalGenerator::GeneratedMakeCommand>
cmGlobalFastbuildGenerator::GenerateBuildCommand(
  const std::string& makeProgram, const std::string& projectName,
  const std::string& projectDir, std::vector<std::string> const& targetNames,
  const std::string& config, bool fast, int jobs, bool verbose,
  std::vector<std::string> const& makeOptions)
{
  // TODO

  return {};
}

const char* cmGlobalFastbuildGenerator::GetCMakeCFGIntDir() const
{
  // TODO
  return "FASTBUILD_CONFIG_INT_DIR";
}

std::string cmGlobalFastbuildGenerator::ConvertToFastbuildPath(
  const std::string& path) const
{
  auto ng = static_cast<cmLocalFastbuildGenerator*>(LocalGenerators[0]);
  return ng->MaybeConvertToRelativePath(
    LocalGenerators[0]->GetState()->GetBinaryDirectory(), path);
}

void cmGlobalFastbuildGenerator::GenerateBffFile()
{
  // Get the root local generator
  auto root = static_cast<cmLocalFastbuildGenerator*>(LocalGenerators[0]);

  // Open bff file for writing
  cmFastbuildFileWriter file{ root->GetMakefile()->GetHomeOutputDirectory() +
                              "/fbuild.bff" };

  file.WriteSingleLineComment("This file was auto-generated by cmake.");

  // Collect all targets
  auto targets = DetectTargetGenerators();

  GenerateBffCompilerSection(file, root->GetMakefile(), targets);

  // TODO: Sort the targets based on dependency order

  GenerateBffTargetSection(file, root->GetMakefile(), targets);
}

void cmGlobalFastbuildGenerator::GenerateBffCompilerSection(
  cmFastbuildFileWriter& file, cmMakefile* makefile,
  const std::set<cmGeneratorTarget*>& targets) const
{
  file.WriteSingleLineComment("Compilers");

  // Output compiler for each language
  std::vector<std::string> compiler_languages;
  for (const auto& language : fastbuild::detail::DetectTargetLanguages(targets)) {
    // Get the root location of the compiler
    std::string variableString = "CMAKE_" + language + "_COMPILER";
    std::string executable = makefile->GetSafeDefinition(variableString);
    if (executable.empty()) {
      continue;
    }

    // Remember language for later
    compiler_languages.push_back(language);

    // Output compiler definition
    cmFastbuildFileWriter::Compiler compiler;
    compiler.Executable = executable;
    compiler.Name = "Compiler_" + language;
    file.Write(compiler);
  }
}

void cmGlobalFastbuildGenerator::GenerateBffTargetSection(
  cmFastbuildFileWriter& file, cmMakefile* makefile,
  const std::set<cmGeneratorTarget*>& targets) const
{
  file.WriteSingleLineComment("Targets");

  // TODO: Should sort
  for (const auto& target : targets) {
    // Skip interfaces
    if (target->GetType() == cmStateEnums::EXECUTABLE ||
        target->GetType() == cmStateEnums::SHARED_LIBRARY ||
        target->GetType() == cmStateEnums::STATIC_LIBRARY ||
        target->GetType() == cmStateEnums::MODULE_LIBRARY ||
        target->GetType() == cmStateEnums::OBJECT_LIBRARY ||
        target->GetType() == cmStateEnums::UTILITY ||
        target->GetType() == cmStateEnums::GLOBAL_TARGET) {
      cmFastbuildTargetGenerator{ file, target }.Generate();
	}
  }
}

std::set<cmGeneratorTarget*>
cmGlobalFastbuildGenerator::DetectTargetGenerators() const
{
  std::set<cmGeneratorTarget*> targets;

  // Loop over each target in each generator in each project
  for (const auto& project : GetProjectMap()) {
    const auto& localGenerators = project.second;
    auto root = localGenerators[0];

    for (const auto& lg : localGenerators) {
      // Skip excluded generators
      if (IsExcluded(root, lg))
        continue;

      for (const auto& target : lg->GetGeneratorTargets()) {
        if (IsRootOnlyTarget(target) &&
            lg->GetMakefile() != root->GetMakefile()) {
          continue;
        }

        targets.insert(target);
      }
    }
  }

  return targets;
}

std::set<std::string> fastbuild::detail::DetectTargetLanguages(
  const std::set<cmGeneratorTarget*>& targets)
{
  std::set<std::string> languages;

  for (auto target : targets) {
    // Skip non-code targets
    auto type = target->GetType();
    if (type == cmStateEnums::INTERFACE_LIBRARY ||
        type == cmStateEnums::UTILITY || type == cmStateEnums::GLOBAL_TARGET)
      continue;

    // Loop through all configs
    std::vector<std::string> configs;
    target->Makefile->GetConfigurations(configs, false);
    for (const auto& config : configs) {
      // Loop through all source objects
      std::vector<const cmSourceFile*> sources;
      target->GetObjectSources(sources, config);
      for (const auto& source : sources) {
        auto language = source->GetLanguage();
        if (!language.empty())
          languages.insert(language);
      }
    }
  }

  return languages;
}
